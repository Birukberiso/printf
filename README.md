This Group project is done by Biruk Beriso and Taiwo Olushoto, we’re embarking on a coding adventure with our latest project, “Printf.” This project is a critical part of our coursework, and it’s all about creating our very own printf function in C. Here’s what we’re up to:

Project Details:

 • Project Name: Printf
 • Group Project led by: Julien Barbier, co-founder & CEO
 • Weight: 5 (A substantial portion of our course grade)

Tasks (from my perspective as a student):

 1. Task 0 - Let’s Get Started: Our journey begins with the first task, where we’ll create a basic printf function. It needs to handle some of the fundamental conversion specifiers, including ‘c’ for characters, ‘s’ for strings, and ‘%’ to print a literal percentage sign.
 2. Task 1 - Dealing with Numbers: Next up, we’re expanding our printf function to handle ‘d’ and ‘i’ conversion specifiers. This will allow us to print integers and is a significant step forward in building our printf function.
 3. Task 2 - Binary Magic: Task 2 is a bit tricky but fascinating. We’re challenged to implement a custom conversion specifier, ‘%b,’ which converts unsigned integers to binary. This means we’re creating our unique formatting rules.
 4. Task 3 - More Specifiers: Task 3 is all about extending our printf function to handle additional conversion specifiers. These include ‘u’ for unsigned integers, ‘o’ for octal, ‘x’ for lowercase hexadecimal, and ‘X’ for uppercase hexadecimal.
 5. Task 4 - Efficiency Matters: To enhance the performance of our code, we’re creating a local buffer in Task 4. The idea is to minimize the number of calls to the ‘write’ function, which is vital for our function’s efficiency.
 6. Task 5 - Custom String Formatter: Here, we’re introducing a custom conversion specifier, ‘%S.’ This allows us to print strings while handling non-printable characters in a specific way. It’s all about customization.
 7. Task 6 - Pointers in Focus: Task 6 leads us into the realm of handling pointers with the ‘p’ conversion specifier. We’re extending our printf function to handle memory addresses.
 8. Task 7 - Flags Unveiled: Now, we’re adding support for flag characters such as ‘+’, ‘space,’ and ‘#’ for non-custom conversion specifiers. Flags provide us with additional formatting options.
 9. Task 8 - Length Matters: Task 8 brings us length modifiers ‘l’ and ‘h’ for conversion specifiers. This is a crucial addition that helps us handle various data types more effectively.
 10. Task 9 - Width Control: In Task 9, we’re working on field width, making sure our printf function aligns and formats output correctly.
 11. Task 10 - Precision Matters: Implementing precision for non-custom conversion specifiers is what Task 10 is all about. This allows us to control the number of decimal places, for instance.
 12. Task 11 - Flag Control: Handling the ‘0’ flag character in Task 11 gives us more control over leading zeros, enhancing formatting capabilities.
 13. Task 12 - Aligning Left: Task 12 introduces the ‘-’ flag character, allowing us to control left alignment and formatting.
 14. Task 13 - Reverse Magic: Task 13 is exciting as we’re creating a custom conversion specifier, ‘%r,’ which prints strings in reverse order. This requires some creative thinking!
 15. Task 14 - Encryption Fun: In our final custom conversion specifier, ‘%R,’ we’ll be encoding strings in Rot13. It’s a cool way to add a layer of security or obscurity to our output.
 16. Task 15 - The Grand Finale: The final task requires us to make sure that all the modifications we’ve made from Tasks 0 to 14 work harmoniously together within our printf function. It’s the big integration stage.

Throughout this project, we’ll be keeping our code in This GitHub repository, and we’ll strictly adhere to the guidelines provided in the project description. Additionally, we’ll create a comprehensive README.md file in our repository to document our project, code structure, and usage instructions.

